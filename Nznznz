# meta developer: @—Ç–≤–æ–π_–Ω–∏–∫
# meta pic: https://img.icons8.com/color/48/000000/artificial-intelligence.png
# scope: hikka_only
# scope: hikka_min 1.6.0

import asyncio
import aiohttp
from .. import loader, utils
import logging

logger = logging.getLogger(__name__)

@loader.tds
class GeminiChatMod(loader.Module):
    """–û–±—â–µ–Ω–∏–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º —á–µ—Ä–µ–∑ Gemini AI"""

    strings = {
        "name": "GeminiChat",
        "no_api_key": "üö´ <b>API –∫–ª—é—á –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω!</b>\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ <code>.gkey <–≤–∞—à_–∫–ª—é—á></code>",
        "config_done": "‚úÖ <b>–ö–ª—é—á —Å–æ—Ö—Ä–∞–Ω–µ–Ω.</b>",
        "already_on": "‚ö†Ô∏è <b>–£–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç</b>",
        "already_off": "‚ö†Ô∏è <b>–£–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>",
        "started": "ü§ñ <b>–†–µ–∂–∏–º –æ–±—â–µ–Ω–∏—è —Å Gemini –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –¥–ª—è {}</b>",
        "stopped": "‚èπÔ∏è <b>–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>",
        "status_on": "üü¢ <b>–°—Ç–∞—Ç—É—Å:</b> –†–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è {}",
        "status_off": "üî¥ <b>–°—Ç–∞—Ç—É—Å:</b> –ù–µ –∞–∫—Ç–∏–≤–µ–Ω",
        "waiting": "ü§î <b>Gemini –¥—É–º–∞–µ—Ç...</b>",
        "error": "‚ùå <b>–û—à–∏–±–∫–∞ Gemini:</b> {}",
        "models_list": "üìã <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:</b>\n{}",
        "no_models": "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π",
        "test_response": "üß™ <b>–¢–µ—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç:</b>\n{}",
        "user_not_found": "‚ö†Ô∏è <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {} –Ω–µ –Ω–∞–π–¥–µ–Ω.</b>\n–ü—Ä–æ–≤–µ—Ä—å, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –æ–Ω –∏ –ø–∏—Å–∞–ª –ª–∏ –æ–Ω —Ç–µ–±–µ —Ö–æ—Ç—å —Ä–∞–∑.",
        "user_id": "üÜî <b>ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</b> {}",
        "user_found": "‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω!</b>\nüë§ {}\nüÜî {}",
        "context_cleared": "üóëÔ∏è <b>–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞ –æ—á–∏—â–µ–Ω–∞</b>",
        "context_size": "üìä <b>–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞:</b> {} —Å–æ–æ–±—â–µ–Ω–∏–π"
    }

    def __init__(self):
        self.target_user = "@rostovskiy7777"
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "gemini_api_key",
                None,
                "API –∫–ª—é—á Google Gemini",
                validator=loader.validators.String()
            ),
            loader.ConfigValue(
                "gemini_model",
                "gemini-2.5-flash",
                "–ú–æ–¥–µ–ª—å Gemini",
                validator=loader.validators.String()
            ),
            loader.ConfigValue(
                "system_prompt",
                "–¢—ã –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û—Ç–≤–µ—á–∞–π —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç–æ –∏ –ø–æ–¥—Ä–æ–±–Ω–æ.",
                "–°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç",
                validator=loader.validators.String()
            ),
            loader.ConfigValue(
                "max_context",
                10,
                "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∏—Å—Ç–æ—Ä–∏–∏",
                validator=loader.validators.Integer(minimum=1, maximum=50)
            )
        )
        self.is_active = False
        self.user_id = None
        self.user_username = None
        self.conversation_history = []

    async def client_ready(self, client, db):
        self.client = client
        self.db = db
        await self._resolve_user()
        self.conversation_history = self.db.get(__name__, "history", [])
        logger.info(f"GeminiChat –∑–∞–≥—Ä—É–∂–µ–Ω. User ID: {self.user_id}")

    async def _resolve_user(self):
        try:
            entity = await self.client.get_entity(self.target_user)
            self.user_id = entity.id
            self.user_username = getattr(entity, 'username', None)
            logger.info(f"–ù–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {self.target_user} (ID: {self.user_id})")
            return True
        except Exception as e:
            logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {self.target_user}: {e}")
            self.user_id = None
            return False

    @loader.command(ru_doc="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å API –∫–ª—é—á")
    async def gkeycmd(self, message):
        key = utils.get_args_raw(message)
        if not key:
            await utils.answer(message, "‚ùå –£–∫–∞–∂–∏—Ç–µ –∫–ª—é—á")
            return
        self.config["gemini_api_key"] = key
        await utils.answer(message, self.strings("config_done"))

    @loader.command(ru_doc="–ü–æ–∫–∞–∑–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏")
    async def gmodelscmd(self, message):
        if not self.config["gemini_api_key"]:
            await utils.answer(message, self.strings("no_api_key"))
            return
        
        models = await self._get_available_models()
        if models:
            text = "\n".join([f"‚Ä¢ <code>{m}</code>" for m in models[:15]])
            await utils.answer(message, self.strings("models_list").format(text))
        else:
            await utils.answer(message, self.strings("no_models"))

    @loader.command(ru_doc="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–¥–µ–ª—å")
    async def gmodelcmd(self, message):
        model = utils.get_args_raw(message)
        if not model:
            await utils.answer(message, f"üìù –¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å: {self.config['gemini_model']}")
            return
        
        model = model.replace("models/", "")
        self.config["gemini_model"] = model
        await utils.answer(message, f"‚úÖ –ú–æ–¥–µ–ª—å –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞: {model}")

    @loader.command(ru_doc="–ù–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    async def gfindcmd(self, message):
        if self.user_id:
            await utils.answer(
                message, 
                self.strings("user_found").format(
                    f"@{self.user_username}" if self.user_username else "–±–µ–∑ username'–∞",
                    self.user_id
                )
            )
        else:
            await self._resolve_user()
            if self.user_id:
                await utils.answer(
                    message, 
                    self.strings("user_found").format(
                        f"@{self.user_username}" if self.user_username else "–±–µ–∑ username'–∞",
                        self.user_id
                    )
                )
            else:
                await utils.answer(
                    message, 
                    self.strings("user_not_found").format(self.target_user)
                )

    @loader.command(ru_doc="–û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –¥–∏–∞–ª–æ–≥–∞")
    async def gclearcmd(self, message):
        self.conversation_history = []
        self.db.set(__name__, "history", [])
        await utils.answer(message, self.strings("context_cleared"))

    @loader.command(ru_doc="–ü–æ–∫–∞–∑–∞—Ç—å —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏")
    async def gcontextcmd(self, message):
        await utils.answer(
            message,
            self.strings("context_size").format(len(self.conversation_history))
        )

    @loader.command(ru_doc="–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ-–æ—Ç–≤–µ—Ç")
    async def gstartcmd(self, message):
        if self.is_active:
            await utils.answer(message, self.strings("already_on").format(self.target_user))
            return
        if not self.config["gemini_api_key"]:
            await utils.answer(message, self.strings("no_api_key"))
            return
        
        if not self.user_id:
            await self._resolve_user()
            if not self.user_id:
                await utils.answer(message, self.strings("user_not_found").format(self.target_user))
                return
        
        self.is_active = True
        await utils.answer(message, self.strings("started").format(self.target_user))

    @loader.command(ru_doc="–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å")
    async def gstopcmd(self, message):
        if not self.is_active:
            await utils.answer(message, self.strings("already_off"))
            return
        self.is_active = False
        await utils.answer(message, self.strings("stopped"))

    @loader.command(ru_doc="–°—Ç–∞—Ç—É—Å")
    async def gstatuscmd(self, message):
        status = self.strings("status_on").format(self.target_user) if self.is_active else self.strings("status_off")
        user_status = f"‚úÖ –ù–∞–π–¥–µ–Ω (ID: {self.user_id})" if self.user_id else "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω"
        
        await utils.answer(
            message,
            f"{status}\n"
            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {user_status}\n"
            f"ü§ñ <b>–ú–æ–¥–µ–ª—å:</b> {self.config['gemini_model']}\n"
            f"üîë <b>–ö–ª—é—á:</b> {'‚úÖ' if self.config['gemini_api_key'] else '‚ùå'}\n"
            f"üìù <b>–ò—Å—Ç–æ—Ä–∏—è:</b> {len(self.conversation_history)} —Å–æ–æ–±—â–µ–Ω–∏–π"
        )

    @loader.command(ru_doc="–ë—ã—Å—Ç—Ä—ã–π —Ç–µ—Å—Ç")
    async def gtestcmd(self, message):
        if not self.config["gemini_api_key"]:
            await utils.answer(message, self.strings("no_api_key"))
            return
        
        thinking = await utils.answer(message, self.strings("waiting"))
        response = await self._query_gemini("–ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ –¥–µ–ª–∞?")
        
        if response.startswith("‚ùå"):
            await thinking.edit(response)
        else:
            await thinking.edit(self.strings("test_response").format(response))

    async def watcher(self, message):
        if not self.is_active:
            return
        if not self.config["gemini_api_key"]:
            return
        if not message.is_private:
            return
        if message.out:
            return
        if not message.raw_text:
            return
        
        sender_id = message.sender_id
        
        if not self.user_id:
            await self._resolve_user()
            if not self.user_id:
                return
        
        if sender_id != self.user_id:
            return

        user_text = message.raw_text
        logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {self.target_user}: {user_text[:50]}...")
        
        self.conversation_history.append({"role": "user", "text": user_text})
        
        max_ctx = self.config["max_context"]
        if len(self.conversation_history) > max_ctx * 2:
            self.conversation_history = self.conversation_history[-max_ctx * 2:]
        
        self.db.set(__name__, "history", self.conversation_history)
        
        thinking = await message.reply(self.strings("waiting"))
        
        response = await self._query_gemini_with_context(user_text)
        
        if not response.startswith("‚ùå"):
            self.conversation_history.append({"role": "assistant", "text": response})
            self.db.set(__name__, "history", self.conversation_history)
        
        if response.startswith("‚ùå"):
            await thinking.edit(response)
        else:
            await thinking.edit(response)

    async def _get_available_models(self):
        api_key = self.config["gemini_api_key"]
        url = f"https://generativelanguage.googleapis.com/v1beta/models?key={api_key}"
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        models = []
                        for m in data.get("models", []):
                            name = m["name"].replace("models/", "")
                            if "generateContent" in m.get("supportedGenerationMethods", []):
                                models.append(name)
                        return models
                    return None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–µ–π: {e}")
            return None

    async def _query_gemini_with_context(self, user_text):
        api_key = self.config["gemini_api_key"]
        model = self.config["gemini_model"]
        
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={api_key}"

        contents = []
        
        for msg in self.conversation_history[-10:]:
            role = "user" if msg["role"] == "user" else "model"
            contents.append({
                "role": role,
                "parts": [{"text": msg["text"]}]
            })
        
        if contents and contents[-1]["role"] == "model":
            contents.append({
                "role": "user",
                "parts": [{"text": user_text}]
            })
        elif not contents or contents[-1]["role"] == "user":
            if contents and contents[-1]["role"] == "user":
                contents[-1]["parts"][0]["text"] = user_text
            else:
                contents.append({
                    "role": "user",
                    "parts": [{"text": user_text}]
                })

        payload = {
            "contents": contents,
            "system_instruction": {
                "parts": [{"text": self.config["system_prompt"]}]
            },
            "generationConfig": {
                "temperature": 0.9,
                "maxOutputTokens": 2048,
                "topP": 0.95,
                "topK": 40
            },
            "safetySettings": [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
            ]
        }

        headers = {"Content-Type": "application/json"}

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=payload, headers=headers, timeout=60) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        try:
                            candidates = data.get("candidates", [])
                            if not candidates:
                                return "‚ùå –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –º–æ–¥–µ–ª–∏"
                            
                            content = candidates[0].get("content", {})
                            parts = content.get("parts", [])
                            if not parts:
                                return "‚ùå –ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç"
                            
                            text = parts[0].get("text", "")
                            if not text:
                                return "‚ùå –ü—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç"
                            
                            return text.strip()
                            
                        except Exception as e:
                            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")
                            return "‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–≤–µ—Ç–∞"
                    
                    elif resp.status == 400:
                        error_text = await resp.text()
                        logger.error(f"Bad Request: {error_text}")
                        return "‚ùå –û—à–∏–±–∫–∞ 400: –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"
                    
                    elif resp.status == 403:
                        return "‚ùå –û—à–∏–±–∫–∞ 403: –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–ª—é—á API"
                    
                    elif resp.status == 404:
                        return f"‚ùå –û—à–∏–±–∫–∞ 404: –ú–æ–¥–µ–ª—å '{model}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
                    
                    else:
                        error_text = await resp.text()
                        return f"‚ùå –û—à–∏–±–∫–∞ {resp.status}"
                        
        except asyncio.TimeoutError:
            return "‚ùå –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ (–ø—Ä–µ–≤—ã—à–µ–Ω–æ 60 —Å–µ–∫—É–Ω–¥)"
        except aiohttp.ClientError as e:
            return f"‚ùå –°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: {e}"
        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞: {e}"

    async def _query_gemini(self, user_text):
        api_key = self.config["gemini_api_key"]
        model = self.config["gemini_model"]
        
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={api_key}"

        payload = {
            "contents": [
                {
                    "role": "user",
                    "parts": [{"text": user_text}]
                }
            ],
            "system_instruction": {
                "parts": [{"text": self.config["system_prompt"]}]
            },
            "generationConfig": {
                "temperature": 0.7,
                "maxOutputTokens": 800,
                "topP": 0.95,
                "topK": 40
            },
            "safetySettings": [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"}
            ]
        }

        headers = {"Content-Type": "application/json"}

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=payload, headers=headers, timeout=30) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        try:
                            candidates = data.get("candidates", [])
                            if not candidates:
                                return "‚ùå –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –º–æ–¥–µ–ª–∏"
                            
                            content = candidates[0].get("content", {})
                            parts = content.get("parts", [])
                            if not parts:
                                return "‚ùå –ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç"
                            
                            text = parts[0].get("text", "")
                            if not text:
                                return "‚ùå –ü—É—Å—Ç–æ–π —Ç–µ–∫—Å—Ç"
                            
                            return text.strip()
                            
                        except Exception as e:
                            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")
                            return "‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–≤–µ—Ç–∞"
                    
                    elif resp.status == 400:
                        error_text = await resp.text()
                        logger.error(f"Bad Request: {error_text}")
                        return "‚ùå –û—à–∏–±–∫–∞ 400: –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø—Ä–æ—Å–∞"
                    
                    elif resp.status == 403:
                        return "‚ùå –û—à–∏–±–∫–∞ 403: –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–ª—é—á API"
                    
                    elif resp.status == 404:
                        return f"‚ùå –û—à–∏–±–∫–∞ 404: –ú–æ–¥–µ–ª—å '{model}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
                    
                    else:
                        error_text = await resp.text()
                        return f"‚ùå –û—à–∏–±–∫–∞ {resp.status}"
                        
        except asyncio.TimeoutError:
            return "‚ùå –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ"
        except aiohttp.ClientError as e:
            return f"‚ùå –°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞: {e}"
        except Exception as e:
            return f"‚ùå –û—à–∏–±–∫–∞: {e}"

    async def on_unload(self):
        self.is_active = False
        self.db.set(__name__, "history", self.conversation_history)
